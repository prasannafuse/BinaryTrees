#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int data[20] = {0};
int newData[30] = {0};
int parityPos[10] = {0};
int i, j, k, dataSize, newDataSize, parityCh, e = 0, errorPos, receivedDataSize, errorCount;
int pbits = 0;
int errorPosCal[10] = {0};

void sender();
void receiver();
void error();
int findParityPos();
int calculateErrorPos();

void sender(){
    //printf("\nData is stored from right to left");
    printf("\nEnter data size : ");
    scanf("%1d", &dataSize);

    //int p = 0;
    //parityPos[pbits]=(int)pow(2,pbits);
    findParityPos();

    printf("\nPbits %d" ,pbits);

    printf("\nEnter binary data :\n");
    for(i = dataSize; i > 0; i--){
        scanf("%d", &data[i]);
    }
    // data[i+1]='\0';
    printf("\nThe original data is ");
    for(i = dataSize; i > 0;i--){
        if(data[i] == 1 || data[i] == 0){
            printf("%d" , data[i]);
        }else{
            printf("\nPlease enter binary data only");
            exit(0);
        }
    }
    k = 0;
    j = 1;
    newDataSize = dataSize+pbits;
    for(i = 1; i <= newDataSize; i++){
        if(i == (int)pow(2,k)){
            newData[i] = 7;
            k++;
        }else{
            newData[i] = data[j];
            j++;
        }
    }

    printf("\nThe intermediate data is ");
    for(i = newDataSize; i > 0;i--){
        printf("%d" , newData[i]);
    }
    //printf("\n%d" , newData);

    printf("\nSet parity : \n1)Even \n2)Odd\nEnter choice : ");
    scanf("%d", &parityCh);
    if(parityCh == 1){
        printf("\nEven parity is set\n");
    }else if(parityCh == 2){
        printf("\nOdd parity is set\n");
    }else{
        printf("\nIncorrect choice so default parity selected as even");
    }
    
    for(i = newDataSize; i > 0 ; i--){
        int q[30];
        int count = 0, a = 0, l = 0;
        int jumpCount = 0;
        // p = pbits;
        
        if(newData[i]==7){
            //newData[i] = 0;
            //printf("\na");
            j = (int)pow(2, pbits-1);
            k = j;
            for(j = k; j <= newDataSize; j++){
                //printf("b");
                //while(k = (int)pow(2, p-1) && p )
                if(jumpCount == k){
                    //printf("c");
                    printf("\nskip j from %d ", j);
                    j = j + k - 1;
                    jumpCount = 0;
                    printf("to %d ", j);
                }else{
                    printf("\nFor P%d positions are %d",i, j);
                    q[a] = newData[j];
                    //printf("\nq[a]%d, %d",j, q[a]);
                    a++;
                    jumpCount++;
                }
            }
            //printf("\ne");
            for(l = 0; l < a; l++){
                if(q[l] == 1){
                    count++;
                }
            }
            pbits--;
             if(parityCh == 1){
                    if(count%2 == 0){
                        newData[i] = 0;
                        
                    } else{
                        newData[i] = 1;
                    }
                    printf("\nP%d: ", i);
                    for(l = 0; l < a; l++){
                        if(q[l] == 7){
                            q[l] = (count%2 == 0) ? 0 : 1;
                        }
                        printf("%d", q[l]);
                    }
                    printf("\n");
                    
                    //break;
                    
                }else if(parityCh == 2){
                    if(count%2 != 0){
                        newData[i] = 0;
                    } else{
                        newData[i] = 1;
                    }
                    // printf("%d", newData);
                    printf("\nP%d: ", i);
                    for(l = 0; l < a; l++){
                        if(q[l] == 7){
                            q[l] = (count%2 == 0) ? 1 : 0;
                        }
                        printf("%d", q[l]);
                    }
                    printf("\n");
                    //break;

                }else{
                    if(count%2 == 0){
                        newData[i] = 0;
                    } else{
                        newData[i] = 1;
                    }
                    printf("\nP%d\n: ", i);
                    for(l = 0; l <= a; l++){
                        if(q[l] == 7){
                            q[l] = (count%2 == 0) ? 0 : 1;
                        }
                        printf("%d", q[l]);
                    }
                    printf("\n");
                    // printf("%d", newData);
                    //break;
            }
        }
    }
    printf("\nThe final data generated is ");
    for(i = newDataSize; i > 0; i--){
        printf("%d", newData[i]);
    }
}

int calculateErrorPos(){
    errorCount = 0;
    printf("\nPBITS %d", pbits);
    printf("\nCalculating error position: ");
    for(j = pbits; j > 0; j--){
        printf("%d", errorPosCal[j]);
    }
    printf("\nPBITS1 %d\n", pbits);
    for(e = pbits; e > 0; e--){
        if(errorPosCal[e] == 1){
            errorCount = errorCount + (int)pow(2,e-1);
        }
        printf("%d", errorPosCal[e]);
    }
    if(errorCount != 0){
        printf("\nError at %d",errorCount);
        return 1;
    }else{
        printf("\nNo error detected");
        return 0;
    }
    return 2;
}

int findParityPos(){
    printf("\nParity positions are : ");
    while(dataSize+pbits >= (int)pow(2,pbits)){
            parityPos[pbits] = (int)pow(2,pbits);
            printf("\nAt position %d\n", parityPos[pbits]);
            pbits++;
    }
    printf("\nParity positions are : \n");
    for(i = 0; i < pbits; i++){
        printf("P%d ", parityPos[i]);
    }
    printf("\nPbits are %d", pbits);
    return pbits;
}

void receiver(){
    int c = 0;
    int receivedData[30];
    
    //printf("\npb : %d", pb);
    printf("\n\nRecived data is : ");
    for(i = newDataSize; i > 0; i--){
        receivedData[i] = newData[i];
        printf("%d", receivedData[i]);
    }
    
    receivedDataSize = newDataSize;
    printf("\nreceivedDataSize : %d", receivedDataSize);
    findParityPos();
    int pb = pbits;
    e = pbits;
    printf("\nPb %d" ,pb);

    for(i = receivedDataSize; i > 0 ; i--){
        int q[10];
        int recCount = 0, a = 0, l, checkOne = 0;
        j = (int)pow(2, pb-1);
        
        if(i == j){
            k = j;
            for(j = k; j <= receivedDataSize; j++){
                if(recCount == k){
                    j = j + k - 1;
                    recCount = 0;
                }else{
                    printf("\n P%d positions are %d",i, j);
                    q[a] = receivedData[j];
                    a++;
                    recCount++;
                }
            }
            printf("\nFor P%d positions are ",i);
            for(l = 0; l < a; l++){
                printf("%d", q[l]);
                if(q[l] == 1){
                    checkOne++;
                }
            }
            printf("\n");
            //printf("\naaa");
            if(receivedData[i] == 1 || receivedData[i] == 0){
                //printf("\naa");
                if(parityCh == 1){
                    if(checkOne%2 == 0){
                        errorPosCal[e] = 0;
                        printf("\nerrorPosCal[e] %d",errorPosCal[e]);
                        printf("\n e %d", e);
                    }else{
                        errorPosCal[e] = 1;
                        printf("\nerrorPosCal[e] %d",errorPosCal[e]);
                        printf("\n e1 %d", e);
                    }
                } else if(parityCh == 2){
                    
                    if(checkOne%2 != 0){
                        errorPosCal[e] = 0;
                        printf("\nerrorPosCal[e] %d",errorPosCal[e]);
                        printf("\n e %d", e);
                    }else{
                        errorPosCal[e] = 1;
                        printf("\nerrorPosCal[e] %d",errorPosCal[e]);
                        printf("\n e1 %d", e);
                    }
                } else {
                    if(checkOne%2 == 0){
                        errorPosCal[e] = 0;
                        printf("\nerrorPosCal[e] %d",errorPosCal[e]);
                        printf("\n e %d", e);
                    }else{
                        errorPosCal[e] = 1;
                        printf("\nerrorPosCal[e] %d",errorPosCal[e]);
                        printf("\n e1 %d", e);
                    }
                }
            }else{
                printf("\nIncorrect data received");
            }
            e--;
            printf("\nPbits %d", pb);
            pb--;
        }
    }
    calculateErrorPos();
    printf("\nFinally recived data is : ");
    for(i = receivedDataSize; i > 0; i--){
        printf("%d", receivedData[i]);
    }
    
}


void error(){
    int errorPos;
    printf("\nEnter position to add error : ");
    scanf("%d", &errorPos);
    //errorPos = newDataSize - errorPos + 1;
    printf("errorPos %d", errorPos);
    newData[errorPos] = (newData[errorPos] == 0) ? 1 : 0;
}

int main(){
    int ch;
    do
    {
       printf("\n\n1) Without error\n2) With error\n3) Exit");
        printf("\nEnter your choice: ");
        scanf("%d", &ch);
        switch (ch)
        {
            case 1:
            {
                sender();
                receiver();
                break;
            }
            case 2:
            {
                sender();
                error();
                receiver();
                break;
            }
            case 3:
            {
                exit(0);
                break;
            }
            default:
            {
                break;
            }
        }
    } while (ch < 4 && ch > 0);
    return 0;
}

hamming
